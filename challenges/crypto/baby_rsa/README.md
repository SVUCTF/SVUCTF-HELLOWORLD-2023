# Baby-RSA

- 作者：Only
- 参考：-
- 难度：Medium
- 分类：Crypto
- 镜像：-
- 端口：-

## 题目描述

## 题目解析

以下来自验题人 @13m0n4de 的题解：

比赛第二天 Crypto 被 AK 了，@Only 有点气急败坏，给了我这题。

这其实是我第一次真正意义上做出 RSA 的题目，所以我大概能站在新生的角度，来分享一下我做题时的经验。

在以往，我都是尽量避开 RSA，就算要做也是「搜索“CTF RSA 常见题型”，一个个对照，看看符合哪题，直接照做」，当然这次也一样，只不过什么也对不上。

我搜索了大概二十分钟，查看到了几个相关的信息：

- `|p - q|` 极小或者极大时，有办法做
- 已知 `|p - q|` 和 `|p + q|` 时，等于脱裤子放屁，能直接知道 p 和 q

可惜与我这题不符啊，这怎么办。

于是我打开了 RSACTFTool 和 yafu ，挂在后台爆破。我没在意太多工具的自定义用法，只当它们是丢进去，就能消耗运气得到 p 和 q 的神奇机器。

与此同时我开始了和 ChatGPT 的聊天，主要就是问问它在已知 `p - q` 的情况下，有没有办法解，因为我之前对比网上的许多题目，发现 `p - q` 是这题最特殊的情况，大概是从此入手。

它稀里糊涂和我聊了很多，大多是在扯淡。RSACTFTool 和 yafu 热得电脑风扇呼呼响，估计也是没戏，我苦恼着接下来的思路。

突然，键盘误触了，编辑器里的 `task.py` 被不小心修改了几个字符，我立马撤销，但还是不放心，找到了附件又确认了一遍几个重要数据的位数（只要没被我不小心插入数字就好）。

这时，我发现 `n` 的位数是 617 ，`p - q` 的位数是 308。

这意味着 `p` 至少有 308 位。

此时来了个疑问：“n 是 617 位的数字，是不是必须要 308 位的数字 乘 309 位的数字才能得到呢？”

虽然是个挺简单的道理，但我还是不确定，于是问了问身边的 ChatGPT：

> ChatGPT：
>
> 要得到一个617位的整数，你需要用一个308位的整数乘以一个309位的整数。这是因为308位整数乘以308位整数会得到616位的整数，再乘以一个1位的整数，最终会得到617位的整数。所以，乘以一个309位的整数就足够了。

哦，那 `p` 是 309 位，`q` 是 308 位。

“同时我不是还知道它们的差 `p - q` 吗？那是不是可以把 308 位的 `q` 爆破一下？反正 `q` 与 `p` 的差是固定的。”

我是这么想的，也是这么做的，但这些数实在是太太太多了。

我看着程序的输出的 `p * q`，发现它们离真正的 n 太远了，小得多。

于是我手动把 q 的爆破起始值调整得大一些（`1e307` -> `9e307`），发现 `p * q` 离 n 近了很多。我继续试了试 `9.5e307`，发现它更近了，但是还是比 n 小。又试了一下 `9.8e307`，它超过了 n 。

“欸？我好像不用遍历来爆破，是可以调整 p 的值来不断逼近 n 的。”

于是我的程序成了这样，从首个数字开始猜解，每位数字从 0 到 9，如果 `p * q` 的值突然大于 `n` 了，那说明上一个猜的数字是正确的。

[crack.py](writeup/crack.py)

```python
p_minus_q = 299910...000888
n = 1241676...1360873

bit_length = 308  # q 的长度
q = ''

while True:
    for guess_number in range(10):
        guess_q = q + str(guess_number)
        guess_q = int(guess_q.ljust(bit_length, '0'))
        guess_p = guess_q + p_minus_q
        guess_n = guess_q * guess_p

        if guess_n > n:
            q += str(guess_number - 1)
            break
        elif guess_n == n:
            print('p: ', guess_p)
            print('q: ', guess_q)
            exit()
    else:
        q += '9'
    # print('q: ', q)
```

运行的时候遇到了一个小问题，那就是跑到了 9 结果 `p * q` 还是小于 n，这时候是正常的，下一位数太大依然会让 `p * q` 超过 `n`。（所以在循环后加了个 `else` ，把这位数设为 9）

运行爆破，一瞬间就得到了 `p` 和 `q`：

```
p:  127430491030186316598772237787200621704115842885224743465563444065385340563124116982965705569260393511394243575695820573459722902414201662771746691743480407808564963801962933879493674560872102800506985571894068885636938969683091312399792296801412448304660202372474525296982700049629504443028082898305571093447
q:  97439484671531165470318718209743648342229901662087729657259306891321910755527075104027117309636595019769045250978737827318896349730607279858029820926755081399552517608675825843262437413543623397564974116410148474526665981710616263353595632860287763962610695089671606467241274266870000940267895766946659092559
```

后来就是普通的解密了，和之前搜索到的很多例题一样。

[solve.py](writeup/solve.py)

```python
from Crypto.Util.number import long_to_bytes

e = 65537
n = 124167...360873
c = 107567...581506

p = 127430...093447
q = 974394...092559

phi_n = (p - 1) * (q - 1)
d = pow(e, -1, phi_n)
m = pow(c, d, n)

flag = long_to_bytes(m)
print(flag.decode())
```

```
flag{803c1a2cb869ea1351c13b9b1e480e48}
```

Flag 是拿到了，但我其实不太明白这段代码，又去问了  ChatGPT，了解了一下 RSA 的基本原理。

希望各位同学也不只要见到 Flag 就停下，多去想想额外的东西。

当然如果你是 @Only 学长，你只要一支笔一张草稿纸开始手搓就好。

