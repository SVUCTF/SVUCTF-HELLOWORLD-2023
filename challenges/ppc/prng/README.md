# 绝对安全的随机数生成器

- 作者：13m0n4de
- 参考：-
- 难度：Medium
- 分类：PPC
- 暴露端口：70

## 题目描述

@zzz：「唉，这次比赛里 Pwn 题好多随机数都可以被预测，我都开始怀疑自己的程序安不安全了。」

@13m0n4de：「确实。」

@zzz：「怎么办呢？你说我用一个超长超复杂的随机种子会不会好一些？」

@zzz：「我懂了，再引入电脑风扇噪声、键盘敲击声音以及室友半夜的怪叫作为生成种子的因素...」

@zzz：「生成一千个随机字符，组合，变换，以地心生物的身份把字符作为垃圾邮件发给地球中潜藏的蜥蜴人，挑拨它们的关系...」

@zzz：「然后，趁乱黑掉天空中的全息投影，操控宇宙射线，把学某通中的作业提交截至时间修改到昨天...」

@zzz：「以班级里挂科的人数，再加上......」

@13m0n4de：「不是，你让新生来退出 Vim 不就好了，保证随机，完全不可预测。」

@zzz：「？」

> Hint：附件中引入的 freshman 文件与此题无关。（本题制作过程中没有任何一位新生受到伤害）

## 题目解析

这题是偏向 Crypto 的 PPC。

考点：梅森算法的破解，预测随机数。

题目附件 [main.py](attachments/main.py)：

```python
#!/usr/local/bin/python

import os
import random
import freshman


FLAG = os.getenv("GZCTF_FLAG", "fake{xxxxxxxx}")

seed = freshman.exit_vim() 
random.seed(seed)

while True:
    number = random.getrandbits(32)
    print("都说了我的种子万无一失，你没办法预测我的随机数")
    ctfer_input = input(f">> ")

    if int(ctfer_input) == number:
        print(FLAG)
        break
    else:
        print(f"猜错了喔，我输入的可是：")
        print(number)
```

在题目给出代码中，使用了 Python 自带的随机数模块 `random`，并且使用了一个很奇怪的 `freshman.exit_vim()` 作为种子，这个只是玩梗，意思是与本题与随机数种子无关，Hint 中也有讲。

在循环中，每次会使用 `random.getrandbits` 生成 32 bit 的整数，如果用户输入的数字与这个整数不符，就会输出它，并继续循环。

### 伪随机数生成器及其内部状态

一些前置知识：

对于大多伪随机数生成器（PRNG），内部状态是其核心组成部分，它包含了生成伪随机数的算法所需的信息和数据，一般会由一个**种子**（Seed）来初始化。

在同一个伪随机数算法中，如果内部状态一致，那么生成出的随机数也将一致。

所以说种子被泄漏，内部状态也就可以初始化为完全一致的数据，继而预测随机数的生成。\
（这次比赛有几道 Pwn 题就是利用了种子。）

本题与种子无关，但核心思想也是**还原内部状态**。

### 梅森旋转算法

在试图还原内部状态之前，先不着急，看看 Python 用的是什么伪随机数生成器。

Python 自带的 `random` 模块使用了 **梅森旋转算法**（Mersene Twister，简称 MT）来生成伪随机数。

MT 算法是一个优秀的伪随机数发生算法，周期长、均匀性好、速度快，但它不是为了密码学随机而设计的，或者说它不是密码学意义上安全的。

在获得足够连续输出的情况下，梅森旋转算法的内部状态能够被还原，继而能够被准确预测输出。

`random` 模块使用随机数生成器叫做 `MT19937`，这里取名 19937 是因为算法使用了梅森素数 `2^19937 - 1`。

别害怕，不讲数学，只是怕你看见名字困惑，你只要了解这个梅什么森什么的数是用来定义 MT 算法的周期的。与本题无关，捎带着了解就可以。

（周期可以简单理解为，生成器在生成随机数序列后，重复生成相同序列所需的步数或次数。）

周期很长没错，但我们说过，我们并不是试图一直循环到周期值，而是**还原内部状态**，以此预测随机数。

### 还原内部状态

终于回到了重点，为什么 MT 算法可以还原内部状态？

这是因为它的提取算法完全基于二进制的按位异或，而二进制按位异或是可逆的。

因为它的提取算法可逆，所以能从输出结果得到内部状态。

但是，它的内部状态是一个很长很长的数组，在 Python 的 `random` 模块中的实现是：19968 位。

也就是 `624 * 32`，624 个大小 32 bit 的整数。

题目附件中得知，每次生成输出的就是一个 32 bit 的整数，那么我们只要接收 624 次，通过“某种操作”（异或等操作，逆向提取算法）还原内部状态，然后就可以用这个内部状态构建生成器，然后生成的随机数就和服务端程序一致啦。

“某种操作”涉及到算法本身，需要太多额外知识，实践中我们可以选择用别人封装好的模块。

### 程序编写

说了这么一大圈，其实我不就是需要收取 624 次整数，然后经过“某种操作”还原内部状态，继而预测下一个数呗，“某种操作”甚至还有现成的库可以调用，分析这么一圈干嘛？

对于一道 PPC 题，这题可能就这样了，但这题的目的是让同学们知道，即使种子够随机了，一些情况下还是可能会导致随机数被预测。

以后也可能会在 Web 题或者 Crypto 题中以其他形式遇到，学点原理总是好的。

那么下面是本题脚本，还原内部状态使用了 [randcrack](https://github.com/fransla/randcrack) 库：

[solve.py](writeup/solve.py)

```python
from pwn import *
from randcrack import RandCrack

# context.log_level = "DEBUG"

rc = RandCrack()

io = remote("127.0.0.1", 8887)

for _ in range(624):
    io.sendlineafter(b">> ", b"0")
    io.recvline()
    recv_data = io.recvline(keepends=False).decode()
    number = int(recv_data)
    rc.submit(number)

next_number = rc.predict_getrandbits(32)

success(next_number)

io.sendlineafter(b">> ", str(next_number).encode())
io.interactive()
```

624 次交互其实也不少，如果开了 `DEBUG` 的话，会因为输出信息太多而变得缓慢的。

## 附录

如果对算法本身的研究感兴趣，可以参考这篇文章：[https://liam.page/2018/01/12/Mersenne-twister/](https://liam.page/2018/01/12/Mersenne-twister/)，讲的很好。

摘一段总结：

> 梅森旋转算法，是一个优秀的伪随机数发生算法。在伪随机数的评价体系中，它是一个相当优秀的算法：周期长、均匀性好、速度快（基本都是位运算）。在条件允可的情形下，若有使用随机数的需求，应首先考虑梅森旋转算法。

> 同时也应该注意到，梅森旋转算法不是为了密码学随机而设计的——在获得足够连续输出的情况下，梅森旋转算法接下来的输出值是可以准确预测的。梅森旋转算法容易被爆破的根源在于，其提取输出函数是可逆的，因此暴露了其内部状态。若要产生密码学上的随机数，可考虑在梅森旋转算法之后，拼接一值得信赖的单向杂凑函数（如 sha256）。否则，若直接用梅森旋转算法的输出值作密码学用途，则有信息泄露的风险，应引起注意。

> 错误应用梅森旋转算法，导致高危漏洞的一个典型是 Discuz! 的密码重置漏洞。
